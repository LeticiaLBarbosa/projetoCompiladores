/**
 * Syntax Specification
 */
package compiler.analysis.generated;
import java_cup.runtime.*;
import util.*;
import core.*;
import java.util.ArrayList;
import java.util.List;

parser code {:

    public void report_error(String message, Object info) {

        StringBuffer internal_message = new StringBuffer("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol symbol = ((java_cup.runtime.Symbol) info);
            if (symbol.left >= 0) {
                internal_message.append(" in line "+(symbol.left+1));
                if (symbol.right >= 0)
                    internal_message.append(", column "+(symbol.right+1));
            }
        }

        internal_message.append(" : "+message);
        System.err.println(internal_message);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(-1);
    }
:};

/* Terminals */
terminal PACKAGE;
terminal SEMICOLON, DOT, COMMA, COLON, QUESTION;
terminal IMPORT;
terminal MULT, DIV, MINUS, PLUS, MOD;
terminal CLASS;
terminal EXTENDS, IMPLEMENTS;
terminal PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, NATIVE, SYNCHRONIZED, ABSTRACT, THREADSAFE, TRANSIENT;
terminal LBRACE, RBRACE;
terminal LPAREN, RPAREN;
terminal LBRACK, RBRACK;
terminal BOOLEAN, BYTE, CHAR, SHORT, INT, FLOAT, LONG, DOUBLE;
terminal RETURN, THROW, BREAK, CONTINUE;
terminal NULL, SUPER, THIS;
terminal INSTANCEOF;
terminal AUTOINCRM, AUTODECRM;
terminal ASSIGNMENT, PLUSASSIGN, MINUSASSIGN, MULTASSIGN, DIVASSIGN, MODASSIGN;
terminal GT, LT, GTEQ, LTEQ, EQEQ, NOTEQ;
terminal NOT, AND, OR, XOR;
terminal ANDASSIGN, ORASSIGN, XORASSIGN;
terminal ANDAND;
terminal TRUE, FALSE;
terminal NEG_BINARY, LSHIFT, RSHIFT, URSHIFT;
terminal RSHIFTASSIGN;
terminal NEW;
terminal X, F, L, E, D;
terminal IF, ELSE;
terminal DO, WHILE, FOR;
terminal TRY, CATCH, FINALLY;
terminal SWITCH, CASE, DEFAULT;
terminal INTERFACE;

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER; // name

/* Non terminals*/
non terminal compilation_unit, package_statement, import_statement, type_declaration, package_name, identifier;
non terminal interface_name, doc_comment, class_declaration, interface_declaration, modifier, class_name;
non terminal field_declaration, method_declaration, constructor_declararion, variable_declaration;
non terminal static_initializer, type, parameter_list, statement_block, type_specifier, parameter, statement;
non terminal expression, if_statement, do_statement, while_statement, for_statement, try_statement, switch_statement;
non terminal numeric_expression, testing_expression, logical_expression, string_expression, bit_expression;
non terminal casting_expression, creating_expression, literal_expression, arglist, integer_literal, float_literal;
non terminal string, character, decimal_digits, exponent_part, float_type_suffix, variable_declarator;
non terminal variable_initializer;

/* Rules */

start with compilation_unit;

compilation_unit ::=
    package_statement
    import_statement
    type_declaration
;

package_statement ::=
    PACKAGE package_name SEMICOLON
;

import_statement ::=
    IMPORT package_name DOT MULT SEMICOLON
    | class_name | interface_name SEMICOLON
;

type_declaration ::=
    doc_comment class_declaration | interface_declaration SEMICOLON
;

doc_comment ::=
    // TODO
;

class_declaration ::=
    modifier CLASS identifier
    EXTENDS class_name
    IMPLEMENTS interface_name COMMA interface_name
    LBRACE field_declaration RBRACE
;

package_name ::=
    identifier
    | package_name DOT identifier
;

interface_name ::=
    identifier
    | package_name DOT identifier
;

interface_declaration ::=
    modifier INTERFACE identifier
    EXTENDS interface_name COMMA interface_name
    LBRACE field_declaration RBRACE
;

modifier ::=
    PUBLIC
    | PRIVATE
    | PROTECTED
    | STATIC
    | FINAL
    | NATIVE
    | SYNCHRONIZED
    | ABSTRACT
    | THREADSAFE
    | TRANSIENT
;

field_declaration ::=
    doc_comment method_declaration
    | constructor_declaration
    | variable_declaration
    | static_initializer
    | SEMICOLON
;

method_declaration ::=
    modifier type identifier
    LPAREN parameter_list RPAREN LBRACK RBRACK
    statement_block | SEMICOLON
;

constructor_declaration ::=
    modifier identifier LPAREN parameter_list RPAREN
    statement_block
;

variable_declaration ::=
    modifier type variable_declarator
    COMMA variable_declarator SEMICOLON
;

static_initializer ::=
    STATIC statement_block
;

type ::=
    type_specifier LBRACK RBRACK
;

parameter_list ::=
    parameter COMMA parameter
;

statement_block ::=
    LBRACE statement RBRACE
;

variable_declarator ::=
    identifier LBRACK RBRACK EQ variable_initializer
;

type_specifier ::=
 	BOOLEAN
    | BYTE
    | CHAR
    | SHORT
    | INT
    | FLOAT
    | LONG
    | DOUBLE
    | class_name
    | interface_name
;

parameter ::=
    type identifier LBRACK RBRACK
;

statement ::=
    variable_declaration
    | expression SEMICOLON
    | statement_block
    | if_statement
    | do_statement
    | while_statement
    | for_statement
    | try_statement
    | switch_statement
    | SYNCHRONIZED LPAREN expression RPAREN statement
    | RETURN expression SEMICOLON
    | THROW expression SEMICOLON
    | identifier COLON statement
    | BREAK identifier SEMICOLON
    | CONTINUE identifier SEMICOLON
    | SEMICOLON
;

if_statement ::=
    IF LPAREN expression RPAREN statement
    ELSE statement
;

do_statement ::=
    DO statement WHILE LPAREN expression RPAREN SEMICOLON
;

while_statement ::=
    WHILE LPAREN expression RPAREN statement
;

for_statement ::=
    FOR LPAREN variable_declaration | expression SEMICOLON | SEMICOLON
    expression SEMICOLON
    expression SEMICOLON
    RPAREN statement
;

try_statement ::=
    TRY statement
    CATCH LPAREN parameter RPAREN statement
    FINALLY statement
;

switch_statement ::= 
    SWITCH LPAREN expression RPAREN LBRACE
    CASE expression COLON
    | DEFAULT COLON 
    | statement 
    RBRACE
;

expression ::= 
    numeric_expression
    | testing_expression 
    | logical_expression 
    | string_expression 
    | bit_expression 
    | casting_expression 
    | creating_expression 
    | literal_expression 
    | NULL 
    | SUPER 
    | THIS 
    |identifier 
    | LPAREN expression RPAREN 
    | expression 
    LPAREN arglist RPAREN 
    | LBRACK expression LBRACK 
    | DOT expression 
    | COMMA expression 
    | INSTANCEOF class_name | interface_name  
;

numeric_expression ::= 
    MINUS
    | AUTOINCRMA
    | AUTODECRM
    expression
    | expression
    AUTOINCRM
    | AUTODECRM
    | expression
    PLUS
    | PLUSASSIGN
    | MINUS
    | MINUSASSIGN
    | MULT
    | MULTASSIGN
    | DIV
    | DIVASSIGN
    | MOD
    | MODASSIGN
    expression
;


//TODO

//testing_expression ::=
// ( expression
// (  ">"
// |  "<"
// |  ">="
// |  "<="
// |  "=="
// |  "!="  )
//expression  )  .
//
//logical_expression  =
// (  "!" expression )
// |  ( expression
// (  "ampersand"
// |  "ampersand="
// |  "|"
// |  "|="
// |  "^"
// |  "^="
// |  (  "ampersand"  "ampersand"  )
// |  "||="
// |  "%"
// |  "%="  )
//expression  )
// |  ( expression  "?" expression  COLON expression )
// |  "true"
// |  "false"  .
//
//string_expression  =  ( expression
// (  "+"
// |  "+="  )
//expression  )  .
//
//bit_expression  =
// (  "~" expression )
// |  ( expression
// (  ">>="
// |  "<<"
// |  ">>"
// |  ">>>"  )
//expression  )  .
//
//casting_expression  =
// LPAREN type  RPAREN expression  .
//
//creating_expression  =
// "new"  (  ( classe_name  LPAREN  [ arglist ]  RPAREN  )
// |  ( type_specifier  [  LBRACK expression  RBRACK  ]  <  LBRACK  RBRACK  >  )
// |  (  LPAREN expression  RPAREN  )  )  .
//
//literal_expression  =
//integer_literal
// | float_literal
// | string
// | character  .
//
//arglist  =
//expression  <  COMMA expression  >  .
//
//type  =
//type_specifier  <  LBRACK  RBRACK  >  .
//
//type_specifier =
// "boolean"
// |  "byte"
// |  "char"
// |  "short"
// |  "int"
// |  "float"
// |  "long"
// |  "double"
// | class_name
// | interface_name  .
//
//modifier =
// "public"
// |  "private"
// |  "protected"
// |  "static"
// |  "final"
// |  "native"
// |  "synchronized"
// |  "abstract"
// |  "threadsafe"
// |  "transient"  .
//
//package_name =
//identifier
// |  ( package_name  DOT identifier )  .
//
//class_name  =
//identifier
// |  ( package_name  DOT identifier )  .
//
//interface_name =
//identifier
// |  ( package_name  DOT identifier )  .
//
//integer_literal =
// (  (  "1..9"  <  "0..9"  >  )
// |  <  "0..7"  >
// |  (  "0"  "x"  "0..9a..f"  <  "0..9a..f"  >  )  )
// [  "l"  ]  .
//
//float_literal  =
// ( decimal_digits  DOT  [ decimal_digits ]  [ exponent_part ]  [ float_type_suffix ]  )
// |  (  DOT decimal_digits  [ exponent_part ]  [ float_type_suffix ]  )
// |  ( decimal_digits  [ exponent_part ]  [ float_type_suffix ]  )  .
//
//decimal_digits  =
// "0..9"  <  "0..9"  >  .
//
//exponent_part  =
// "e"  [  "+"  |  MINUS  ] decimal_digits  .
//
//float_type_suffix  =
// "f"  |  "d"  .
//
//character  =
//  "based on the unicode character set"  .
//
//string  =
// "''"  < character  >  "''"  .
//
//identifier  =
//  "a..z,$,_"  <  "a..z,$,_,0..9,unicode character over 00C0"  >  .