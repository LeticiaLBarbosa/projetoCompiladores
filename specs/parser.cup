/**
 * Syntax Specification
 */
package compiler.analysis.generated;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;

parser code {:

    public void report_error(String message, Object info) {

        StringBuffer internal_message = new StringBuffer("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol symbol = ((java_cup.runtime.Symbol) info);
            if (symbol.left >= 0) {
                internal_message.append(" in line "+(symbol.left+1));
                if (symbol.right >= 0)
                    internal_message.append(", column "+(symbol.right+1));
            }
        }

        internal_message.append(" : "+message);
        System.err.println(internal_message);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(-1);
    }
:};

/* Terminals */
terminal PACKAGE;
terminal SEMICOLON, DOT, COMMA, COLON, QUESTION;
terminal IMPORT;
terminal MULT, DIV, MINUS, PLUS, MOD;
terminal CLASS;
terminal EXTENDS, IMPLEMENTS;
terminal PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, NATIVE, SYNCHRONIZED, ABSTRACT, THREADSAFE, TRANSIENT;
terminal LBRACE, RBRACE;
terminal LPAREN, RPAREN;
terminal LBRACK, RBRACK;
terminal BOOLEAN, BYTE, CHAR, SHORT, INT, FLOAT, LONG, DOUBLE, VOID;
terminal RETURN, THROW, BREAK, CONTINUE;
terminal NULL, SUPER, THIS;
terminal INSTANCEOF;
terminal AUTOINCRM, AUTODECRM;
terminal ASSIGNMENT, PLUSASSIGN, MINUSASSIGN, MULTASSIGN, DIVASSIGN, MODASSIGN;
terminal GT, LT, GTEQ, LTEQ, EQEQ, NOTEQ;
terminal NOT, AND, OR, XOR;
terminal ANDASSIGN, ORASSIGN, XORASSIGN;
terminal ANDAND, OROR;
terminal TRUE, FALSE;
terminal NEG_BINARY, LSHIFT, RSHIFT, URSHIFT;
terminal RSHIFTASSIGN, LSHIFTASSIGN;
terminal NEW;
terminal X, F, L, E, D;
terminal IF, ELSE;
terminal DO, WHILE, FOR;
terminal TRY, CATCH, FINALLY;
terminal SWITCH, CASE, DEFAULT;
terminal INTERFACE;

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARLITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER;

/* Non terminals*/
non terminal compilation_unit, package_statement, import_statement, type_declaration, package_name, identifier;
non terminal interface_name, doc_comment, class_declaration, interface_declaration, modifier, class_name;
non terminal field_declaration, method_declaration, constructor_declaration, variable_declaration;
non terminal static_initializer, type, parameter_list, statement_block, type_specifier, parameter, statement;
non terminal expression, if_statement, do_statement, while_statement, for_statement, try_statement, switch_statement;
non terminal numeric_expression, testing_expression, logical_expression, string_expression, bit_expression;
non terminal casting_expression, creating_expression, literal_expression, arglist, integer_literal, float_literal;
non terminal string, character, decimal_digits, exponent_part, float_type_suffix, variable_declarator;
non terminal variable_initializer, package_opt, extends_opt, implements_opt, interface_args, modifier_opt;
non terminal arglist_opt, decimal_digits_opt

/* Precedences */

precedence nonassoc DOT, LPAREN, LBRACK;
precedence left DIV, MULT;
precedence left PLUS, MINUS;


/* Rules */

start with compilation_unit;

arglist_opt ::= | arglist
;
decimal_digits_opt ::= | decimal_digits
;
package_opt ::=
    | package_statement
;

compilation_unit ::=
    package_opt import_statement type_declaration
    | package_opt import_statement
    | package_opt type_declaration
    | package_opt
;

package_statement ::=
    PACKAGE package_name SEMICOLON
;

import_statement ::=
    IMPORT package_name DOT MULT SEMICOLON
    | class_name | interface_name SEMICOLON
;

type_declaration ::=
    doc_comment class_declaration | interface_declaration SEMICOLON
;

doc_comment  ::=  "/**" text "*/"
;

extends_opt ::=
    | EXTENDS class_name
;

implements_opt ::=
    | IMPLEMENTS interface_name interface_args
;

implements_compl ::=
    | COMMA interface_name
;

class_declaration ::=
    modifier_opt CLASS identifier
    extends_opt
    implements_opt
    LBRACE field_declaration RBRACE
;

package_name ::=
    identifier
    | package_name DOT identifier
;

interface_name ::=
    identifier
    | package_name DOT identifier
;

interface_declaration ::=
    modifier INTERFACE identifier
    EXTENDS interface_name COMMA interface_name
    LBRACE field_declaration RBRACE
;

modifier_opt ::= | modifier

modifier ::=
    PUBLIC
    | PRIVATE
    | PROTECTED
    | STATIC
    | FINAL
    | NATIVE
    | SYNCHRONIZED
    | ABSTRACT
    | THREADSAFE
    | TRANSIENT
;

field_declaration ::=
    doc_comment_opt method_declaration
    | doc_comment_opt constructor_declaration
    | doc_comment_opt variable_declaration
    | static_initializer
    | SEMICOLON
;

method_declaration ::=
    modifier type identifier
    LPAREN parameter_list RPAREN LBRACK RBRACK
    statement_block | SEMICOLON
;

constructor_declaration ::=
    modifier_opt identifier LPAREN parameter_list RPAREN statement_block
;

variable_declaration ::=
    modifier type variable_declarator
    COMMA variable_declarator SEMICOLON
;

static_initializer ::=
    STATIC statement_block
;

type ::=
    type_specifier LBRACK RBRACK
;

parameter_list ::=
    parameter COMMA parameter
;

statement_block ::=
    LBRACE statement RBRACE
;

variable_declarator ::=
    identifier LBRACK RBRACK ASSIGNMENT variable_initializer
;

type_specifier ::=
 	BOOLEAN
    | BYTE
    | CHAR
    | SHORT
    | INT
    | FLOAT
    | LONG
    | DOUBLE
    | class_name
    | interface_name
;

parameter ::=
    type identifier LBRACK RBRACK
;

statement ::=
    variable_declaration
    | expression SEMICOLON
    | statement_block
    | if_statement
    | do_statement
    | while_statement
    | for_statement
    | try_statement
    | switch_statement
    | SYNCHRONIZED LPAREN expression RPAREN statement
    | RETURN expression SEMICOLON
    | THROW expression SEMICOLON
    | identifier COLON statement
    | BREAK identifier SEMICOLON
    | CONTINUE identifier SEMICOLON
    | SEMICOLON
;

if_statement ::=
    IF LPAREN expression RPAREN statement
    ELSE statement
;

do_statement ::=
    DO statement WHILE LPAREN expression RPAREN SEMICOLON
;

while_statement ::=
    WHILE LPAREN expression RPAREN statement
;

for_statement ::=
    FOR LPAREN variable_declaration | expression SEMICOLON | SEMICOLON
    expression SEMICOLON
    expression SEMICOLON
    RPAREN statement
;

try_statement ::=
    TRY statement
    CATCH LPAREN parameter RPAREN statement
    FINALLY statement
;

switch_statement ::=
    SWITCH LPAREN expression RPAREN LBRACE
    CASE expression COLON
    | DEFAULT COLON
    | statement
    RBRACE
;

expression ::=
    numeric_expression
    | testing_expression
    | logical_expression
    | string_expression
    | bit_expression
    | casting_expression
    | creating_expression
    | literal_expression
    | NULL
    | SUPER
    | THIS
    | identifier
    | LPAREN expression RPAREN
    | expression LPAREN arglist_opt RPAREN
    | expression LBRACK expression RBRACK
    | expression DOT expression
    | expression COMMA expression
    | expression INSTANCEOF class_name
    | expression INSTANCEOF interface_name
;

numeric_expression ::=
    MINUS
    | AUTOINCRM
    | AUTODECRM
    expression
    | expression
    AUTOINCRM
    | AUTODECRM
    | expression
    PLUS
    | PLUSASSIGN
    | MINUS
    | MINUSASSIGN
    | MULT
    | MULTASSIGN
    | DIV
    | DIVASSIGN
    | MOD
    | MODASSIGN
    expression
;

testing_expression ::=
    expression
    GT
    | LT
    | GTEQ
    | LTEQ
    | EQEQ
    | NOTEQ
    expression
;

logical_expression ::=
    NOT expression
    | expression
    AND
    | ANDASSIGN
    | OR
    | ORASSIGN
    | XOR
    | XORASSIGN
    | ANDAND
    | MOD
    | MODASSIGN
    expression
    | expression QUESTION expression COLON expression
    | TRUE
    | FALSE
;

string_expression ::=
    expression
    PLUS
    | PLUSASSIGN
    expression
;

bit_expression ::=
    NEG_BINARY expression
    | expression RSHIFTASSIGN expression
    | expression LSHIFT expression
    | expression RSHIFT expression
    | expression URSHIFT expression
;

casting_expression ::=
    LPAREN type RPAREN expression
;

creating_expression ::=
    NEW class_name LPAREN arglist_opt RPAREN
    | NEW type_specifier LBRACK expression RBRACK LBRACK RBRACK
    | NEW type_specifier LBRACK expression RBRACK
    | NEW type_specifier
    | NEW LPAREN expression RPAREN
;

literal_expression ::=
    integer_literal
    | float_literal
    |string
    |character
;

arglist ::=
    expression COMMA expression
;

type ::=
    type_specifier LBRACK RBRACK
;

type_specifier ::=
    BOOLEAN
    | BYTE
    | CHAR
    | SHORT
    | INT
    | FLOAT
    | LONG
    |DOUBLE
    | class_name
    | interface_name
;

modifier ::=
    PUBLIC
    | PRIVATE
    | PROTECTED
    | STATIC
    | FINAL
    | NATIVE
    | SYNCHRONIZED
    | ABSTRACT
    | THREADSAFE
    | TRANSIENT
;

package_name ::=
    identifier
    | package_name DOT identifier
;

class_name ::=
    identifier
    | package_name DOT identifier
;

interface_name ::=
    identifier
    | package_name DOT identifier
;

integer_literal ::=
    INTEGER_LITERAL
;

float_literal ::=
    decimal_digits DOT decimal_digits exponent_part float_type_suffix
    | DOT decimal_digits exponent_part float_type_suffix
    | decimal_digits exponent_part float_type_suffix
;

decimal_digits ::=
    INTEGER_LITERAL
;

exponent_part ::=
    E decimal_digits
    | E PLUS decimal_digits
    | E MINUS decimal_digits
;

float_type_suffix ::=
    F
    | D
;

character ::=
    CHARLITERAL
;

string ::=
    STRING_LITERAL
;

identifier ::=
    IDENTIFIER
;
