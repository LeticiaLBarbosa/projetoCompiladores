/**
 * Syntax Specification
 */
package compiler.generated;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import util.*;

parser code {:

    public void report_error(String message, Object info) {

        StringBuffer internal_message = new StringBuffer("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol symbol = ((java_cup.runtime.Symbol) info);
            if (symbol.left >= 0) {
                internal_message.append(" in line "+(symbol.left+1));
                if (symbol.right >= 0)
                    internal_message.append(", column "+(symbol.right+1));
            }
        }
        System.err.println("Info: "+info.toString());
        internal_message.append(" : "+message);
        System.err.println(internal_message);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(-1);
    }
:};

/* Terminals */
terminal PACKAGE;
terminal SEMICOLON, DOT, COMMA, COLON, QUESTION;
terminal IMPORT;
terminal MULT, DIV, MINUS, PLUS, MOD;
terminal CLASS;
terminal EXTENDS, IMPLEMENTS;
terminal PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, NATIVE, SYNCHRONIZED, ABSTRACT, THREADSAFE, TRANSIENT;
terminal LBRACE, RBRACE;
terminal LPAREN, RPAREN;
terminal LBRACK, RBRACK;
terminal BOOLEAN, BYTE, CHAR, SHORT, INT, FLOAT, LONG, DOUBLE, VOID;
terminal RETURN, THROW, BREAK, CONTINUE;
terminal NULL, SUPER, THIS;
terminal INSTANCEOF;
terminal AUTOINCRM, AUTODECRM;
terminal ASSIGNMENT, PLUSASSIGN, MINUSASSIGN, MULTASSIGN, DIVASSIGN, MODASSIGN;
terminal GT, LT, GTEQ, LTEQ, EQEQ, NOTEQ;
terminal NOT, AND, OR, XOR;
terminal ANDASSIGN, ORASSIGN, XORASSIGN;
terminal ANDAND, OROR;
terminal TRUE, FALSE;
terminal NEG_BINARY, LSHIFT, RSHIFT, URSHIFT;
terminal RSHIFTASSIGN, LSHIFTASSIGN;
terminal NEW;
terminal X, F, L, E, D;
terminal IF, ELSE;
terminal DO, WHILE, FOR;
terminal TRY, CATCH, FINALLY;
terminal SWITCH, CASE, DEFAULT;
terminal INTERFACE;

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.String CHARACTER_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal IDENTIFIER;

/* Non terminals*/
non terminal compilation_unit, package_statement, import_statement, type_declaration, package_name, identifier;
non terminal interface_name, doc_comment, class_declaration, interface_declaration, modifier, class_name;
non terminal field_declaration, method_declaration, constructor_declaration, variable_declaration;
non terminal static_initializer, type, parameter_list, statement_block, type_specifier, parameter, statement;
non terminal expression, if_statement, do_statement, while_statement, for_statement, try_statement, switch_statement;
non terminal numeric_expression, testing_expression, logical_expression, string_expression, bit_expression;
non terminal casting_expression, creating_expression, literal_expression, arglist, integer_literal, float_literal;
non terminal string, character, decimal_digits, exponent_part, float_type_suffix, variable_declarator;
non terminal variable_initializer, package_opt, extends_opt, implements_opt, interface_args, modifier_opt;
non terminal arglist_opt, decimal_digits_opt, exponent_part_opt, float_type_suffix_opt, variable_declaration_opt;
non terminal expression_opt, doc_comment_opt, extends_interface_opt, field_declaration_opt, parameter_list_opt;
non terminal identifier_opt, statement_opt, switch_statement_body, catch_opt, finally_opt;
non terminal variable_declarator_body, variable_initializer_body;

/* Precedences */

precedence nonassoc DOT, LPAREN, LBRACK;
precedence left DIV, MULT;
precedence left PLUS, MINUS;


/* Rules */

start with compilation_unit;

arglist_opt ::= | arglist
;
decimal_digits_opt ::= | decimal_digits
;
package_opt ::=
    | package_statement:p {: Logger.print("120 package_opt" + p); :}
;

compilation_unit ::=
    package_opt import_statement type_declaration {: Logger.print("120 compilationUnit"); :}
    | package_opt import_statement
    | package_opt type_declaration
    | package_opt
;

package_statement ::=
    PACKAGE package_name SEMICOLON
;

import_statement ::=
    IMPORT package_name DOT MULT SEMICOLON SEMICOLON
    | IMPORT class_name SEMICOLON
    | IMPORT interface_name SEMICOLON
;

type_declaration ::=
    doc_comment_opt class_declaration SEMICOLON
    | doc_comment_opt interface_declaration SEMICOLON
;

doc_comment  ::=  /** "  text "*/
;

extends_opt ::=
    | EXTENDS class_name
;

implements_opt ::=
    | IMPLEMENTS interface_name interface_args
;

interface_args ::=
    | COMMA interface_name interface_args
;

class_declaration ::=
    modifier_opt CLASS identifier
    extends_opt
    implements_opt
    LBRACE field_declaration RBRACE
;

package_name ::=
    identifier
    | package_name DOT identifier
;

interface_name ::=
    identifier
    | package_name DOT identifier
;

interface_declaration ::=
    modifier_opt INTERFACE identifier
    extends_interface_opt LBRACE field_declaration_opt RBRACE
;

extends_interface_opt ::=
    | EXTENDS interface_name interface_args
;

modifier_opt ::= | modifier
;
modifier ::=
    PUBLIC
    | PRIVATE
    | PROTECTED
    | STATIC
    | FINAL
    | NATIVE
    | SYNCHRONIZED
    | ABSTRACT
    | THREADSAFE
    | TRANSIENT
;

field_declaration ::=
    doc_comment_opt method_declaration
    | doc_comment_opt constructor_declaration
    | doc_comment_opt variable_declaration
    | static_initializer
    | SEMICOLON
;

method_declaration ::=
    modifier_opt type identifier LPAREN parameter_list_opt RPAREN LBRACK RBRACK statement_block
    | modifier_opt type identifier LPAREN parameter_list_opt RPAREN LBRACK RBRACK SEMICOLON
    | modifier_opt type identifier LPAREN parameter_list_opt RPAREN statement_block
    | modifier_opt type identifier LPAREN parameter_list_opt RPAREN SEMICOLON
;

constructor_declaration ::=
    modifier_opt identifier LPAREN parameter_list RPAREN statement_block
;

variable_declarator_body ::=
    | COMMA variable_declarator variable_declarator_body
;

variable_declaration ::=
    modifier_opt type variable_declarator variable_declarator_body SEMICOLON
;

static_initializer ::=
    STATIC statement_block
;

type ::=
    type_specifier LBRACK RBRACK
;

parameter_list ::=
    parameter
    | parameter COMMA parameter_list
;

statement_block ::=
    LBRACE statement_opt RBRACE
;

variable_declarator ::=
    identifier LBRACK RBRACK ASSIGNMENT variable_initializer
    | identifier LBRACK RBRACK
    | identifier ASSIGNMENT variable_initializer
    | identifier
;

variable_declarator_body ::=
    | COMMA variable_initializer variable_initializer_body
;
variable_initializer ::=
    expression
    | LBRACE variable_initializer variable_initializer_body  RBRACE
    | LBRACE variable_initializer variable_initializer_body  COMMA RBRACE
    | LBRACE RBRACE
;

type_specifier ::=
 	BOOLEAN
    | BYTE
    | CHAR
    | SHORT
    | INT
    | FLOAT
    | LONG
    | DOUBLE
    | class_name
    | interface_name
;

parameter ::=
    type identifier LBRACK RBRACK
    | type identifier
;

statement ::=
    variable_declaration
    | expression SEMICOLON
    | statement_block
    | if_statement
    | do_statement
    | while_statement
    | for_statement
    | try_statement
    | switch_statement
    | SYNCHRONIZED LPAREN expression RPAREN statement
    | RETURN expression_opt SEMICOLON
    | THROW expression SEMICOLON
    | identifier COLON statement
    | BREAK identifier_opt SEMICOLON
    | CONTINUE identifier_opt SEMICOLON
    | SEMICOLON
;

if_statement ::=
    IF LPAREN expression RPAREN statement
    | IF LPAREN expression RPAREN statement ELSE statement
;

do_statement ::=
    DO statement WHILE LPAREN expression RPAREN SEMICOLON
;

while_statement ::=
    WHILE LPAREN expression RPAREN statement
;

for_statement ::=
    FOR LPAREN variable_declaration expression_opt SEMICOLON expression_opt SEMICOLON RPAREN statement
    | FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt SEMICOLON RPAREN statement
    | FOR LPAREN SEMICOLON expression_opt SEMICOLON expression_opt SEMICOLON RPAREN statement
;

catch_opt ::=
    CATCH LPAREN parameter RPAREN statement
;

finally_opt ::=
    FINALLY statement
;

try_statement ::=
    TRY statement catch_opt finally_opt

;

switch_statement_body ::=
  | CASE expression COLON switch_statement_body
  | DEFAULT COLON switch_statement_body
  | statement switch_statement_body
;

switch_statement ::=
    SWITCH LPAREN expression RPAREN LBRACE switch_statement_body RBRACE
;

expression ::=
    numeric_expression
    | testing_expression
    | logical_expression
    | string_expression
    | bit_expression
    | casting_expression
    | creating_expression
    | literal_expression
    | NULL
    | SUPER
    | THIS
    | identifier
    | LPAREN expression RPAREN
    | expression LPAREN arglist_opt RPAREN
    | expression LBRACK expression RBRACK
    | expression DOT expression
    | expression COMMA expression
    | expression INSTANCEOF class_name
    | expression INSTANCEOF interface_name
;

numeric_expression ::=
    MINUS expression
    | AUTOINCRM expression
    | AUTODECRM expression
    | expression AUTOINCRM
    | expression AUTODECRM
    | expression PLUS expression
    | expression MINUS expression
    | expression PLUSASSIGN expression
    | expression MINUSASSIGN expression
    | expression MULT expression
    | expression MULTASSIGN expression
    | expression DIV expression
    | expression DIVASSIGN expression
    | expression MOD expression
    | expression MODASSIGN expression
;

testing_expression ::=
    expression GT expression
    | expression LT expression
    | expression LTEQ expression
    | expression GTEQ expression
    | expression EQEQ expression
    | expression NOTEQ expression
;

logical_expression ::=
    NOT expression
    | expression  AND expression
    | expression ANDASSIGN expression
    | expression OR expression
    | expression ORASSIGN expression
    | expression XOR expression
    | expression XORASSIGN expression
    | expression ANDAND expression
    | expression MOD expression
    | expression MODASSIGN expression
    | expression QUESTION expression COLON expression
    | TRUE
    | FALSE
;

string_expression ::=
    expression PLUS expression
    | expression PLUSASSIGN expression
;

bit_expression ::=
    NEG_BINARY expression
    | expression RSHIFTASSIGN expression
    | expression LSHIFT expression
    | expression RSHIFT expression
    | expression URSHIFT expression
;

casting_expression ::=
    LPAREN type RPAREN expression
;

creating_expression ::=
    NEW class_name LPAREN arglist_opt RPAREN
    | NEW type_specifier LBRACK expression RBRACK LBRACK RBRACK
    | NEW type_specifier LBRACK expression RBRACK
    | NEW type_specifier
    | NEW LPAREN expression RPAREN
;

literal_expression ::=
    integer_literal
    | float_literal
    | string
    | character
;

arglist ::=
    expression COMMA expression
;

type ::=
    type_specifier LBRACK RBRACK
    | type_specifier
;

type_specifier ::=
    BOOLEAN
    | BYTE
    | CHAR
    | SHORT
    | INT
    | FLOAT
    | LONG
    |DOUBLE
    | class_name
    | interface_name
;

modifier ::=
    PUBLIC
    | PRIVATE
    | PROTECTED
    | STATIC
    | FINAL
    | NATIVE
    | SYNCHRONIZED
    | ABSTRACT
    | THREADSAFE
    | TRANSIENT
;

package_name ::=
    identifier
    | package_name DOT identifier
;

class_name ::=
    identifier
    | package_name DOT identifier
;

interface_name ::=
    identifier
    | package_name DOT identifier
;

integer_literal ::=
    INTEGER_LITERAL
;

float_literal ::=
    decimal_digits DOT decimal_digits_opt exponent_part_opt float_type_suffix_opt
    | DOT decimal_digits exponent_part_opt float_type_suffix_opt
    | decimal_digits exponent_part_opt float_type_suffix_opt
;

decimal_digits ::=
    INTEGER_LITERAL
;

exponent_part ::=
    E decimal_digits
    | E PLUS decimal_digits
    | E MINUS decimal_digits
;

float_type_suffix ::=
    F
    | D
;

character ::=
    CHARACTER_LITERAL
;

string ::=
    STRING_LITERAL
;

identifier ::=
    IDENTIFIER:i {: Logger.print("475 identifier " + i ); :}
;

float_type_suffix_opt ::= | float_type_suffix
;

exponent_part_opt ::= | exponent_part
;
variable_declaration_opt ::=
    | variable_declaration
;
expression_opt ::=
    | expression
;
 field_declaration_opt ::=
    | field_declaration
;

parameter_list_opt ::=
    | parameter_list
;

identifier_opt ::=
    | identifier
;

statement_opt ::=
    | statement
;

doc_comment_opt ::=
    | doc_comment
;
